import data.complex.basic

open nat
open complex

structure arithmetic : Type :=
(f : â„• â†’ â„‚)

notation `ð”¸` := arithmetic

@[simp] theorem eta : âˆ€ f : ð”¸, arithmetic.mk f.f = f
| âŸ¨aâŸ© := rfl

@[extensionality] theorem ext : âˆ€ {f g : ð”¸}, f.f = g.f â†’ f = g
| âŸ¨_âŸ© âŸ¨_âŸ© rfl := rfl

@[extensionality] theorem ext' : âˆ€ {f g : ð”¸}, (âˆ€ (n : â„•), f.f n = g.f n) â†’ f = g :=
begin
    intros f g h,
    have w := funext h,
    simp at w,
    exact (ext w),
end

instance : has_zero ð”¸ := âŸ¨arithmetic.mk (Î» n, 0)âŸ©
instance : inhabited ð”¸ := âŸ¨0âŸ©
instance : has_add ð”¸ := âŸ¨Î» f g, arithmetic.mk (Î» n, f.f n + g.f n)âŸ© 

lemma zerof (n : â„•) : ((0 : ð”¸).f n) = 0 := by refl
lemma zerof_re (n : â„•) : ((0 : ð”¸).f n).re = 0 := by {rw [zerof], refl}
lemma zerof_im (n : â„•) : ((0 : ð”¸).f n).im = 0 := by {rw [zerof], refl}

theorem arithmetic_add_zero (f : ð”¸) : f + 0 = f :=
begin
    apply ext',
    intros n,
    dsimp [(+), 0],
    rw [zerof_re, zerof_im],
    have w_re : distrib.add (f.f n).re 0 = (f.f n).re := by exact add_zero _,
    have w_im : distrib.add (f.f n).im 0 = (f.f n).im := by exact add_zero _,
    rw [w_re, w_im],
    simp only [complex.eta],
end

theorem arithmetic_add_comm (f g : ð”¸) : f + g = g + f :=
begin
    apply ext',
    intros n,
    dsimp [(+)],
    have wâ‚ : distrib.add (f.f n).re (g.f n).re = distrib.add (g.f n).re (f.f n).re := by exact add_comm _ _,
    have wâ‚‚ : distrib.add (f.f n).im (g.f n).im = distrib.add (g.f n).im (f.f n).im := by exact add_comm _ _,
    rw [wâ‚, wâ‚‚],
end

theorem arithmetic_zero_add (f : ð”¸) : 0 + f = f :=
begin
    rw [arithmetic_add_comm],
    exact arithmetic_add_zero f,
end

theorem arithmetic_add_assoc (f g h : ð”¸) : (f + g) + h = f + (g + h) :=
begin
    apply ext',
    intros n,
    dsimp [(+)],
    have wâ‚ : distrib.add (distrib.add ((f.f n).re) ((g.f n).re)) ((h.f n).re) = distrib.add ((f.f n).re) (distrib.add ((g.f n).re) ((h.f n).re)) := by exact add_assoc _ _ _,
    have wâ‚‚ : distrib.add (distrib.add ((f.f n).im) ((g.f n).im)) ((h.f n).im) = distrib.add ((f.f n).im) (distrib.add ((g.f n).im) ((h.f n).im)) := by exact add_assoc _ _ _,
    rw [wâ‚, wâ‚‚],
end

instance : add_comm_monoid ð”¸ :=
{add := (+), add_assoc := arithmetic_add_assoc, zero := 0, zero_add := arithmetic_zero_add, add_zero := arithmetic_add_zero, add_comm := arithmetic_add_comm}

instance : has_one ð”¸ := âŸ¨arithmetic.mk (Î» n, if n â‰¤ 1 then 1 else 0)âŸ©
instance : has_mul ð”¸ := âŸ¨Î» f g, arithmetic.mk (Î» n, if n â‰¤ 1 then (f.f n) * (g.f n) else list.sum (list.map (Î» d, f.f d * g.f (n / d)) (factors n)))âŸ©

lemma mul_one_case_zero (f : ð”¸) : (f * 1).f 0 = f.f 0 :=
begin
    dsimp [(*)],
    simp,
    have wâ‚ : ((1 : ð”¸).f 0).re = 1 := by refl,
    have wâ‚‚ : ((1 : ð”¸).f 0).im = 0 := by refl,
    have wâ‚ƒ : no_zero_divisors.mul ((f.f 0).re) 1 = (f.f 0).re := by exact mul_one _,
    have wâ‚„ : (no_zero_divisors.mul ((f.f 0).im)) 0 = 0 := by exact mul_zero _,
    have wâ‚… : no_zero_divisors.mul ((f.f 0).im) 1 = (f.f 0).im := by exact mul_one _,
    have wâ‚† : (no_zero_divisors.mul ((f.f 0).re)) 0 = 0 := by exact mul_zero _,
    rw [wâ‚, wâ‚‚, wâ‚ƒ, wâ‚„, wâ‚…, wâ‚†],
    simp,
end

lemma mul_one_case_one (f : ð”¸) : (f * 1).f 1 = f.f 1 :=
begin
    dsimp [(*)],
    have w : 1 â‰¤ 1 := by linarith,
    simp [w],
    have wâ‚ : ((1 : ð”¸).f 1).re = 1 := by refl,
    have wâ‚‚ : ((1 : ð”¸).f 1).im = 0 := by refl,
    have wâ‚ƒ : no_zero_divisors.mul ((f.f 1).re) 1 = (f.f 1).re := by exact mul_one _,
    have wâ‚„ : (no_zero_divisors.mul ((f.f 1).im)) 0 = 0 := by exact mul_zero _,
    have wâ‚… : no_zero_divisors.mul ((f.f 1).im) 1 = (f.f 1).im := by exact mul_one _,
    have wâ‚† : (no_zero_divisors.mul ((f.f 1).re)) 0 = 0 := by exact mul_zero _,
    rw [wâ‚, wâ‚‚, wâ‚ƒ, wâ‚„, wâ‚…, wâ‚†],
    simp,
end
.

theorem mul_one (f : ð”¸) : f * 1 = f :=
begin
    apply ext',
    intros n,
    cases n,
    
    exact mul_one_case_zero f,

    cases n,

    exact mul_one_case_one f,
    
    dsimp [(*)],
    have w : n + 2 > 1 := by linarith,
    dsimp [(>)] at w,
    rw [lt_iff_not_ge] at w,
    dsimp [(â‰¥)] at w,
    simp [w],
    
end









